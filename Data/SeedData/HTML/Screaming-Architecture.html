<div id="blog">
  <div>
    <h1>Screaming Architecture</h1>
    <div>30 September 2011</div>
    <article>
      <p>Imagine that you are looking at the blueprints of a building. This document, prepared by an architect, tells you the plans for the building. What do these plans tell you?</p>

<p>If the plans you are looking at are for a single family residence, then you’ll likely see a front entrance, a foyer leading to a living room and perhaps a dining room. There’ll likely be a kitchen a short distance away, close to the dining room. Perhaps a dinette area next to the kitchen, and probably a family room close to that. As you looked at those plans, there’d be no question that you were looking at a <em>house</em>. The architecture would <em>scream</em>: <strong>house</strong>.</p>

<p>Or if you were looking at the architecture of a library, you’d likely see a grand entrance, an area for check-in-out clerks, reading areas, small conference rooms, and gallery after gallery capable of holding bookshelves for all the books in the library. That architecture would <em>scream</em>: <strong>Library</strong>.</p>

<p>So what does the architecture of your application scream? When you look at the top level directory structure, and the source files in the highest level package; do they scream: <strong>Health Care System</strong>, or <strong>Accounting System</strong>, or <strong>Inventory Management System</strong>? Or do they scream: <strong>Rails</strong>, or <strong>Spring/Hibernate</strong>, or <strong>ASP</strong>?</p>

<h3 id="the-theme-of-an-architecture">The Theme of an Architecture</h3>

<p>Go back and read Ivar Jacobson’s seminal work on software architecture: Object Oriented Software Engineering. Notice the subtitle of the book: <em>A use case driven approach.</em> In this book Ivar makes the point that software architectures are structures that support the use cases of the system. Just as the plans for a house or a library scream about the use cases of those buildings, so should the architecture of a software application scream about the use cases of the application.</p>

<p>Architectures are not (or should not) be about frameworks. Architectures should not be <em>supplied</em> by frameworks. Frameworks are tools to be used, not architectures to be conformed to. If your architecture is based on frameworks, then it <em>cannot</em> be based on your use cases.</p>

<h3 id="the-purpose-of-an-architecture">The Purpose of an Architecture</h3>

<p>The reason that good architectures are centered around use-cases is so that architects can safely describe the structures that support those use-cases without committing to frameworks, tools, and environment. Again, consider the plans for a house. The first concern of the architect is to make sure that the house is usable, it is not to ensure that the house is made of bricks. Indeed, the architect takes pains to ensure that the homeowner can decide about bricks, stone, or cedar <em>later</em>, after the plans ensure that the use cases are met.</p>

<p>A good software architecture allows decisions about frameworks, databases, web-servers, and other environmental issues and tools, to be deferred and delayed. A good architecture makes it unnecessary to decide on Rails, or Spring, or Hibernate, or Tomcat or MySql, until <em>much</em> later in the project. A good architecture makes it easy to change your mind about those decisions too. A good architecture emphasizes the use-cases and decouples them from peripheral concerns.</p>

<h3 id="but-what-about-the-web">But what about the Web?</h3>

<p>Is the web an architecture? Does the fact that your system is delivered on the web dictate the architecture of your system? <em>Of course not!</em> The Web is a delivery mechanism, and your application architecture should treat it as such. The fact that your application is delivered over the web is a <em>detail</em> and should not dominate your system structure. Indeed, the fact that your application is delivered over the web is something you should <em>defer</em>. Your system architecture should be as ignorant as possible about how it is to be delivered. You should be able to deliver it as a console app, or a web app, or a thick client app, or even a web service app, without undue complication or change to the fundamental architecture.</p>

<h3 id="frameworks-are-tools-not-ways-of-life">Frameworks are tools, not ways of life.</h3>

<p>Frameworks can be very powerful and very useful. Framework authors often <em>believe</em> in their frameworks. The examples they write for how to use their frameworks are told from the point of view of a <em>true believer</em>. Other authors who write about the framework also tend to be disciples of the true belief. They show you <em>the way</em> to use the framework. Often it is an all-encompassing, all-pervading, let-the-framework-do-everything position. This is not the position you want to take.</p>

<p>Look at each framework with a jaded eye. View it skeptically. Yes, it might help, but at what cost. How should I use it, and how should I protect myself from it. How can I preserve the use-case emphasis of my architecture? How can I prevent the framework from taking over that architecture.</p>

<h3 id="testable-architectures">Testable Architectures.</h3>

<p>If you system architecture is all about the use cases, and if you have kept your frameworks at arms-length. Then you should be able to unit-test all those use cases without any of the frameworks in place. You shouldn’t need the web server running in order to run your tests. You shouldn’t need the database connected in order to run your tests. Your business objects should be plain old objects that have no dependencies on frameworks or databases or other complications. Your use case objects should coordinate your business objects. And all of them together should be testable in-situ, without any of the complications of frameworks.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Your architectures should tell readers about the system, not about the frameworks you used in your system. If you are building a health-care system, then when new programmers look at the source repository, their first impression should be: “Oh, this is a heath-care system”. Those new programmers should be able to learn all the use cases of the system, and still not know how the system is delivered. They may come to you and say: “We see some things that look sorta like models, but where are the views and controllers”, and you should say: “Oh, those are details that needn’t concern you at the moment, we’ll show them to you later.”</p>

<hr />

<p>For more on this topic, see Episode VII - Architecture, Use-cases, and High Level Design, at <a href="http://cleancoders.com">cleancoders.com</a>.</p>



    </article>
  </div>
</div>
