<main>
<article>
<div class = 'paperBody'>
<p>Test-Driven Development (TDD) is a technique for building
  software that guides software development by writing tests. It was
  developed by <a href = 'https://substack.com/@kentbeck'>Kent
  Beck</a> in the late 1990's as part of
  Extreme Programming. In essence we follow three simple
  steps repeatedly:</p>

<ul>
<li>Write a test for the next bit of functionality you want to add.</li>

<li>Write the functional code until the test passes.</li>

<li>Refactor both new and old code to make it well structured.</li>
</ul>

<div class = 'figure '><img src = 'https://martinfowler.com/bliki/images/test-driven-development/card.png'></img>
<p class = 'photoCaption'></p>
</div>

<p>Although these three steps, often summarized as <i>Red - Green -
  Refactor</i>, are the heart of the process, there's also a vital initial
  step where we write out a list of test cases first. We then pick one of these
  tests, apply red-green-refactor to it, and once we're done pick the next.
  Sequencing the tests properly is a skill, we want to pick tests that drive us
  quickly to the salient points in the design. During the process we should add
  more tests to our lists as they occur to us.</p>

<p>Writing the test first, what <a href="https://www.amazon.com/gp/product/0321278658/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321278658&linkCode=as2&tag=martinfowlerc-20">XPE2</a> calls
  Test-First Programming, provides two main benefits. Most obviously it's a way
  to get <a href = '/bliki/SelfTestingCode.html'>SelfTestingCode</a>, since we can only write some functional
  code in response to making a test pass. The second benefit is that thinking
  about the test first forces us to think about the interface to the code first.
  This focus on interface and how you use a class helps us separate interface
  from implementation, a key element of good design that many programmers
  struggle with.</p>

<p>The most common way that I hear to screw up TDD is neglecting
  the third step. Refactoring the code to keep it clean is a key part
  of the process, otherwise we just end up with a messy aggregation of
  code fragments. (At least these will have tests, so it's a less
  painful result than most failures of design.)</p>

<div class = 'furtherReading'>
<h2>Further Reading</h2>

<p>Kent's summary of the <a href = 'https://tidyfirst.substack.com/p/canon-tdd'>canonical way to do TDD</a>
    is the key online summary.</p>

<p>For more depth, head to Kent Beck's book
    <a href="https://www.amazon.com/gp/product/0321146530/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321146530&linkCode=as2&tag=martinfowlerc-20">Test-Driven Development</a>.</p>

<p>The relevant chapter of James Shore's <a href="https://www.amazon.com/gp/product/1492080691/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1492080691&linkCode=as2&tag=martinfowlerc-20">The
    Art of Agile Development</a> is another sound description that also
    connects it to the rest of effective agile development. James also wrote a
    series of screencasts called <a href = 'http://www.jamesshore.com/Blog/Lets-Play'>Let's Play TDD</a>.</p>
</div>

<div class = 'revisions'>
<h2>Revisions</h2>

<p>My original post of this page was 2005-03-05. Inspired by Kent's
    canonical post, I updated it on 2023-12-11</p>
</div>
</div>
</article>

<div class = 'clear'></div>
</main>
